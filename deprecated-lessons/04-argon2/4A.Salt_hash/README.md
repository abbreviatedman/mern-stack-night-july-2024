# 4A. Argon2 Hash & Salt

---

## What this lesson covers:

- What is Argon2
- Getting Started
- Hashing & Salting
- Types of attacks

---

### What is Argon2

Argon2 is a password-hashing function that is designed to securely hash passwords and protect against various types of attacks, including brute-force attacks and dictionary attacks. When a user creates an account or updates their password, the backend of our application will use Argon2 to encrypt the user's password before storing it into the database (MongoDB) or verifying the password that's already encrypted & stored. This ensures that even if the database is compromised, an attacker cannot easily retrieve the original passwords.

### Getting Started

First installing Argon2 using the following command:

```bash
npm install argon2
```

### Hash & Salting

Passwords are often stored in databases to verify users when they log in. Currently, we're able to see any string or text clearly in the database. However, passwords should be hidden so that nobody (even the owner of an app) can see them. Storing passwords directly in the database poses a security risk, especially if the database is compromised. Salting is a technique used to add an extra layer of security to passwords stored in databases. In JavaScript, the Argon2 module automatically adds a salt to the password during the hashing process.

Hashing is a process used to convert plain passwords (with or without salts) into a fixed-length string of characters called a hash value. hashing algorithms are designed to be one-way functions, meaning that it's computationally infeasible to reverse-engineer the original password from the hash value. You can think of it like cooking food, cooking is a 1-way process. It would be infeasible to un-cook the food and retrieve the original ingredients.

With the Argon2 module, this is an example of hashing a password:

```js
const argon2 = require("argon2");

async function hashPassword(pass) {
  try {
    // 1-way send
    const sentReceipt = await argon2.hash(pass);
    return sentReceipt;
  } catch (error) {
    console.error("error hashing password: " + error);
  }
}
```

The `sentReceipt` variable contains a promise. You don't get back the encrypted password until you use another `await` keyword, similar to this:

```js
async function getBackPassword(pass) {
  const returnedPass = await hashPassword(pass);
  return returnedPass;
}

getBackPassword("fakePass123");
```

Here we've chained 2 functions together. The first function sends your password to Argon2 for hashing (you hand over the ingredients, they cook it). The second function returns the encrypted password (cooked meal).

When you do this, you will get back an encrypted password that looks like this:

```
$argon2id$v=19$m=65536,t=3,p=4$KP+E9j6nmyqcRFuKbC+WxQ$6JsfaG/kd8a00RM6hmTtQ2t7fOzlilYJueacNli4dDI
```

Let's break this down into bite sized pieces so we can understand what we're looking at.

- **$argon2id**: This tells us the variant of Argon2 used for hashing. In this case, it's the "argon2id" variant, which is a hybrid version of "argon2i" and "argon2d". This variant is commonly recommended for most use cases due to its security properties.

- **$v=19**: This is the version of the Argon2 algorithm. Different versions may include improvements, bug fixes, or changes to the algorithm over time.

- **$m=65536**: This specifies the memory cost parameter used during the hashing process. The value 65536 indicates that 65536 kilobytes (or 64 megabytes) of memory are used for hashing. Increasing the memory cost parameter makes the hashing process more memory-intensive and helps mitigate certain types of attacks, such as GPU-based attacks.

- **t=3**: This denotes the time cost parameter used during the hashing process. The value 3 indicates that the hashing process is performed for 3 iterations. Increasing the time cost parameter makes the hashing process more computationally expensive, and slows down attackers attempting to brute-force or crack hashed passwords.

- **p=4**: This represents the parallelism parameter used during the hashing process. The value 4 indicates that the hashing process is parallelized across 4 threads or processes, making use of multi-core CPUs for faster computation. Higher values of the parallelism parameter increase the computational parallelism and may improve hashing performance on multi-core systems.

- **$KP+E9j6nmyqcRFuKbC+WxQ**: This is the salt used during the hashing process. The salt is a randomly generated value that adds uniqueness to each hashed password, even if two users have the same plain-text password. Salting helps prevent attackers from using precomputed tables (rainbow tables) to reverse hashed passwords.

- **$6JsfaG/kd8a00RM6hmTtQ2t7fOzlilYJueacNli4dDI**: This is the final hashed password generated by Argon2. It's the result of hashing the plain-text password (combined with the salt) using the specified parameters (memory cost, time cost, parallelism) of the Argon2 algorithm.

This entire string is what will be stored in the database, and used to verify the password on the next log-in. The various parameters seen in the breakdown is what tells Argon2 how the original password was encrypted (like a recipe). Argon2 will use this to re-encrypt the next password during a log-in and compare the 2 encrypted passwords:

```js
async function verifyPassword() {
  try {
    let signUpPassword = "fakePass123";
    let encryptedSignUpPassword = await hashPassword(signUpPassword);
    let logInPassword = "fakePass123";

    // Verify the plain password against the hashed password
    const isMatch = await argon2.verify(encryptedSignUpPassword, logInPassword);
    return isMatch;
  } catch (error) {
    console.error("Error verifying password:", error);
    throw error;
  }
}

// Call verifyPassword asynchronously
verifyPassword()
  .then((result) => {
    console.log(result); // Will log either true or false
  })
  .catch((error) => {
    console.error("Error:", error);
  });
```

In this function, the `isMatch` variable will return either true or false.

### Types of attacks

1. **Brute-force attacks**: Attempting every possible combination of characters until the correct password is found. Attackers start with the simplest combinations (ie. single characters) and gradually increase the complexity until they find a match. Brute-force attacks don't rely on pre-existing lists of passwords or words.

ğŸ›¡ï¸ Argon2's defense ğŸ›¡ï¸: Argon2 slows down brute-force attacks by requiring a significant amount of computational resources (time & memory) to compute each hash. By increasing the time & memory costs parameters, Argon2 makes it computationally expensive and time-consuming for attackers to hash passwords, effectively slowing down brute-force attacks.

2. **Dictionary attacks**: Trying a list of commonly used passwords or words from a dictionary to guess the correct password. Attackers use pre-existing lists of passwords, wordlists, or dictionaries, which may include common words, phrases, or passwords leaked from previous data breaches.

ğŸ›¡ï¸ Argon2's defense ğŸ›¡ï¸: Argon2 mitigates dictionary attacks by using a salt, which adds random data to each password before hashing. This ensures that even if two users have the same password, their hashed representations will be different due to the unique salt. As a result, attackers cannot use precomputed tables (rainbow tables) to reverse hashed passwords.

3. **Timing attacks**: Exploiting variations in the time taken to execute certain operations to infer information about the hashed password. By measuring the time it takes to compute the hash, attackers may gain insights into the hashed password's structure or characteristics.

ğŸ›¡ï¸ Argon2's defense ğŸ›¡ï¸: Argon2 is designed to be resistant to timing attacks by ensuring that the time taken to compute the hash remains consistent, regardless of the input password. This prevents attackers from extracting information about the hashed password through timing discrepancies.

4. **Cache-timing attacks**: Exploiting variations in access times to different memory locations to infer information about the hashed password. By observing these timing differences, attackers may gain insights into the hashed password.

ğŸ›¡ï¸ Argon2's defense ğŸ›¡ï¸: Argon2 employs memory-hardness properties, ensuring that the algorithm's memory access patterns are unpredictable and do not reveal information about the hashed password. This makes cache-timing attacks less feasible against systems using Argon2.
