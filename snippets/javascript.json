{
  // Place your snippets for javascript here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  // "Print to console": {
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "MERN-index-imports": {
    "prefix": "server-imp",
    "body": [
      "const express = require('express');",
      "const app = express();",
      "const path = require('path');",
      "const logger = require('morgan')",
      "const connectToMongoDB = require('./db/mongodb');",
      "require('dotenv').config();"
    ],
    "description": "Make some basic imports for your backend server in the MERN stack"
  },
  "MERN-index-middleware": {
    "prefix": "server-mid",
    "body": [
      "// Read incoming requests properly",
      "app.use(express.urlencoded({ extended: false }));",
      "app.use(express.json());",
      "// logs requests to the server",
      "app.use(logger('dev'))"
    ],
    "description": "Necessary middleware"
  },
  "MERN-index-routes": {
    "prefix": "server-routes",
    "body": [
      "const ${1:collectionName}Router = require('./routes/${1:collectionName}Router');",
      "// localhost:3001/${1:collectionName}/...",
      "app.use('/${1:collectionName}', ${1:collectionName}Router);"
    ],
    "description": "insert-description-here"
  },
  "MERN-index-power": {
    "prefix": "server-pow",
    "body": [
      "const PORT = 3001",
      "",
      "app.listen(PORT, () => {",
      "    console.log(`server listening on port 3001`);",
      "",
      "    connectToMongoDB();",
      "});"
    ],
    "description": "this lets us turn the server on"
  },
  "MERN-db-mongo": {
    "prefix": "connect-mongo",
    "body": [
      "const mongoose = require('mongoose');",
      "require('dotenv').config()",
      "",
      "function connectToMongoDB(){",
      "    mongoose.connect(process.env.MONGODB_URI)",
      "        .then(() => {",
      "            console.log('MONGODB CONNECTED')",
      "        })",
      "        .catch((e) => {",
      "            console.log(e)",
      "        });",
      "};",
      "",
      "module.exports = connectToMongoDB;"
    ],
    "description": "Create the entire db/mongodb.js file. There is nothing to customize here"
  },
  "MERN-model-schema": {
    "prefix": "model-schema",
    "body": [
      "const mongoose = require('mongoose');",
      "",
      "const ${1:model}Schema = new mongoose.Schema(",
      "    {",
      "        ${2:property}: {",
      "            type: String,",
      "            unique: true,",
      "            required: true",
      "        },",
      "    }",
      ")",
      "",
      "const ${1:model} = mongoose.model('${1:model}', ${1:model}Schema);",
      "",
      "module.exports = ${1:model};"
    ],
    "description": "Creates an example Model/Schema file, replace the words 'model' with the name of your data collection"
  },
  "MERN-router": {
    "prefix": "router-template",
    "body": [
      "const router = require('express').Router();",
      "",
      "const {",
      "    getAll${1:model}s,",
      "    getOne${1:model},",
      "    createOne${1:model},",
      "    deleteOne${1:model},",
      "    updateOne${1:model}",
      "} = require('../controllers/${1:model}Controller');",
      "",
      "// localhost:3001/${1:model}/all${1:model}s",
      "router.get('/all${1:model}s', getAll${1:model}s);",
      "",
      "// localhost:3001/${1:model}/one${1:model}/:${2:params}",
      "router.get('/one${1:model}/:${2:params}', getOne${1:model});",
      "",
      "// localhost:3001/${1:model}/createOne${1:model}",
      "router.post('/createOne${1:model}', createOne${1:model});",
      "",
      "// localhost:3001/${1:model}/deleteOne${1:model}/:${2:params}",
      "router.delete('/deleteOne${1:model}/:${2:params}', deleteOne${1:model});",
      "",
      "// localhost:3001/${1:model}/updateOne${1:model}/:${2:params}",
      "router.put('/updateOne${1:model}/:${2:params}', updateOne${1:model});",
      "",
      "module.exports = router;"
    ],
    "description": "insert-description-here"
  },
  "MERN-controller": {
    "prefix": "controller-template",
    "body": [
      "const ${1:collectionName} = require('../models/${1:collectionName}Model');",
      "",
      "async function getAll${1:collectionName}s (req, res) {",
      "    try {",
      "        let results = await ${1:collectionName}.find({});",
      "",
      "        res.json({",
      "            message: 'success',",
      "            payload: results",
      "        })",
      "    } catch (error) {",
      "        let errorObj = {",
      "            message: 'get all ${1:collectionName} failure',",
      "            payload: error",
      "        }",
      "",
      "        console.log(errorObj)",
      "",
      "        res.json(errorObj)",
      "    }",
      "}",
      "",
      "async function getOne${1:collectionName} (req, res) {",
      "    try {",
      "        let result = await ${1:collectionName}.findOne({${2:propertyName}: req.params.${2:propertyName}});",
      "",
      "        res.json({",
      "            message: 'success',",
      "            payload: result",
      "        })",
      "    } catch (error) {",
      "        let errorObj = {",
      "            message: 'get ONE ${1:collectionName} failure',",
      "            payload: error",
      "        }",
      "",
      "        console.log(errorObj)",
      "",
      "        res.json(errorObj)",
      "    }",
      "}",
      "",
      "async function createOne${1:collectionName}(req, res){",
      "    try {",
      "        // Accepting the front-end form data from the client to generate the document",
      "        let new${1:collectionName} = req.body",
      "",
      "",
      "",
      "        // post the new document to the ${1:collectionName} collection",
      "        await ${1:collectionName}.create(new${1:collectionName});",
      "",
      "        res.json({",
      "            message: 'success',",
      "            payload: new${1:collectionName}",
      "        });",
      "    } catch (error) {",
      "        let errorObj = {",
      "            message: 'create one ${1:collectionName} failure',",
      "            payload: error",
      "        }",
      "",
      "        console.log(errorObj);",
      "",
      "        res.json(errorObj);",
      "    }",
      "}",
      "",
      "async function deleteOne${1:collectionName}(req, res) {",
      "    try {",
      "        await ${1:collectionName}.deleteOne({ ${2:propertyName}: req.params.${2:propertyName} });",
      "",
      "        res.json({",
      "            message: 'success',",
      "            payload: req.params.${2:propertyName}",
      "        })",
      "    } catch (error) {",
      "        let errorObj = {",
      "            message: 'delete one ${1:collectionName} failure',",
      "            payload: error",
      "        }",
      "",
      "        console.log(errorObj);",
      "",
      "        res.json(errorObj);",
      "    }",
      "}",
      "",
      "async function updateOne${1:collectionName}(req, res){",
      "    try {",
      "        let target${1:collectionName} = await ${1:collectionName}.findOne({ ${2:propertyName}: req.params.${2:propertyName} })",
      "",
      "        // ternaries avoid inputting undefined values",
      "        let updated${1:collectionName} = {",
      "            ${2:propertyName}: req.body.${2:propertyName} ? req.body.${2:propertyName} : target${1:collectionName}.${2:propertyName},",
      "        }",
      "",
      "        await ${1:collectionName}.updateOne(",
      "            { ${2:propertyName}: req.params.${2:propertyName} },",
      "            { $$set: updated${1:collectionName} },",
      "            { upsert: true }",
      "        )",
      "",
      "        res.json({",
      "            message: 'success',",
      "            payload: updated${1:collectionName}",
      "        });",
      "    } catch (error) {",
      "        let errorObj = {",
      "            message: 'update one ${1:collectionName} failure',",
      "            payload: error",
      "        }",
      "",
      "        console.log(errorObj);",
      "",
      "        res.json(errorObj);",
      "    }",
      "}",
      "",
      "module.exports = {",
      "    getAll${1:collectionName}s,",
      "    getOne${1:collectionName},",
      "    createOne${1:collectionName}, ",
      "    deleteOne${1:collectionName},",
      "    updateOne${1:collectionName}",
      "}"
    ],
    "description": "Replace 'collectionName' with the name of the data collection that is being controlled. Replace 'propertyName' with the different properties from the data that can be used to find/update/delete from the database. Make sure to look carefully at the create/update functions, as generating a new document depends on the original Model"
  },
  "Argon2-controller": {
    "prefix": "argon2-controls",
    "body": [
      "const User = require('../models/userModel')",
      "const argon2 = require('argon2')",
      "",
      "async function createUser(req, res) {",
      "    try {",
      "        // temporarily hold password",
      "        let userPassword = req.body.password",
      "",
      "        // encrypt password",
      "        const sentPassword = await argon2.hash(userPassword)",
      "",
      "        // generate new user document",
      "        let newUser = {",
      "            username: req.body.username,",
      "            password: sentPassword",
      "        }",
      "",
      "        // insert document into the database",
      "        await User.create(newUser)",
      "",
      "        res.json({",
      "            message: 'success',",
      "            payload: newUser",
      "        })",
      "    } catch (error) {",
      "        let errorObj = {",
      "            message: 'create user failure',",
      "            payload: error",
      "        }",
      "",
      "        res.json(errorObj)",
      "        console.log(errorObj)",
      "    }",
      "}",
      "",
      "async function verifyPassword(req, res) {",
      "    try {",
      "        // hold username & password individually",
      "        let incomingUsername = req.body.username",
      "        let incomingPassword = req.body.password",
      "",
      "        // find the target user",
      "        let foundUser = await User.findOne({ username: incomingUsername })",
      "",
      "        // compare passwords",
      "        const isCorrectPassword = await argon2.verify(foundUser.password, incomingPassword)",
      "",
      "        // respond based on password correctness",
      "        if (isCorrectPassword) {",
      "            res.json({",
      "                message: 'verify password success',",
      "                payload: 'logged in!'",
      "            })",
      "        } else {",
      "            res.json({",
      "                message: 'verify password success',",
      "                payload: 'Please check your password and try again'",
      "            })",
      "        }",
      "    } catch (error) {",
      "        let errorObj = {",
      "            message: 'verify password failure',",
      "            payload: error",
      "        }",
      "",
      "        res.json(errorObj)",
      "        console.log(errorObj)",
      "    }",
      "}",
      "",
      "async function updatePassword(req, res) {",
      "    try {",
      "        // capture all necessary info",
      "        const { username, oldPassword, newPassword } = req.body",
      "",
      "        // Target the correct user",
      "        let foundUser = await User.findOne({ username: username })",
      "",
      "        // Verify the original password is correct",
      "        let isCorrectPassword = await argon2.verify(foundUser.password, oldPassword)",
      "",
      "        // Double check that the new password isn't the same as the old one",
      "        let isSamePassword = await argon2.verify(foundUser.password, newPassword)",
      "",
      "        // respond accordingly",
      "        if (isCorrectPassword && !isSamePassword) {",
      "            const newSafePassword = await argon2.hash(newPassword)",
      "",
      "            foundUser.password = newSafePassword",
      "",
      "            await foundUser.save()",
      "            res.json({",
      "                message: 'update password success',",
      "                payload: 'Your password has been updated!'",
      "            })",
      "        } else if (isSamePassword) {",
      "            res.json({",
      "                message: 'update password success',",
      "                payload: 'New password must be different from the old password'",
      "            })",
      "        } else {",
      "            res.json({",
      "                message: 'update password success',",
      "                payload: 'Original password is incorrect, please check the spelling and try again'",
      "            })",
      "        }",
      "    } catch (error) {",
      "        let errorObj = {",
      "            message: 'update password failure',",
      "            payload: error",
      "        }",
      "",
      "        res.json(errorObj)",
      "        console.log(errorObj)",
      "    }",
      "}",
      "",
      "module.exports = {",
      "    createUser,",
      "    verifyPassword,",
      "    updatePassword",
      "}"
    ],
    "description": "password encryption controller. verifyPassword() can be used as part of a login process, make sure to coordinate properly with whatever login method you're using"
  },
  "User-model": {
    "prefix": "user-model",
    "body": [
      "const mongoose = require('mongoose')",
      "",
      "const userSchema = new mongoose.Schema(",
      "    {",
      "        username: {",
      "            type: String,",
      "            required: true,",
      "            unique: true",
      "        },",
      "        password: {",
      "            type: String,",
      "            required: true",
      "        }",
      "    }",
      ")",
      "",
      "const User = mongoose.model('User', userSchema)",
      "",
      "module.exports = User"
    ],
    "description": "User model with mongoose, can coordinate with argon2/bcrypt for password encryption"
  },
  "User-router": {
    "prefix": "user-router",
    "body": [
      "const router = require('express').Router()",
      "",
      "const {",
      "    createUser,",
      "    verifyPassword,",
      "    updatePassword",
      "} = require('../controllers/userController')",
      "",
      "// localhost:3001/user/createUser",
      "router.post('/createUser', createUser)",
      "",
      "// localhost:3001/user/verifyPassword",
      "router.post('/verifyPassword', verifyPassword)",
      "",
      "// localhost:3001/user/updatePassword",
      "router.put('/updatePassword', updatePassword)",
      "",
      "module.exports = router"
    ],
    "description": "This connects with the user-controller snippet"
  },
  "EJS-middleware": {
    "prefix": "ejs-middleware",
    "body": [
      "app.set('view engine', 'ejs')",
      "app.set('views', path.join(__dirname, 'views'))",
      "app.use(express.static(path.join(__dirname, 'public')))"
    ],
    "description": "create the middleware necessary for EJS as a rendering engine"
  },
  "Login-middleware": {
    "prefix": "server-login",
    "body": [
      "const session = require('express-session')",
      "const MongoStore = require('connect-mongo')",
      "",
      "// LOGIN SESSION MIDDLWARE",
      "app.use(session(",
      "    {",
      "        secret: process.env.SECRET_SESSION_KEY,",
      "        resave: false,",
      "        saveUninitialized: true,",
      "        store: MongoStore.create({",
      "            mongoUrl: process.env.MONGODB_URI",
      "        }),",
      "        cookie: {",
      "            maxAge: 24 * 60 * 60 * 1000 // 24 hours",
      "        }",
      "    }",
      "))"
    ],
    "description": "combo of express-session and connect-mongo to store sessions in the database. 24 hour maxAge cookies"
  },
  "Auth-middleware": {
    "prefix": "auth-middleware",
    "body": [
      "const User = require('../models/userModel');",
      "",
      "// TLDR: checks if a session exists and session contains user's unique ID... if so CONTINUE, else redirect to login page",
      "function requireAuth(req, res, next) {",
      "    if (req.session && req.session.userId) {",
      "        return next();",
      "    } else {",
      "        req.session.loginMessage = 'You must login to access this page.';",
      "        res.redirect('/login');",
      "    }",
      "}",
      "",
      "//if logged in, attach user's obj to the session!",
      "async function isLoggedIn(req, res, next) {",
      "    try ",
      "    {",
      "        if (req.session && req.session.userId) ",
      "        {",
      "            req.session.activeUser = await User.findOne({_id: req.session.userId});",
      "            req.session.activeUser.password = ''; // safety first",
      "",
      "            return next();",
      "        }",
      "        else ",
      "        {",
      "            req.session.activeUser = null;",
      "",
      "            return next();",
      "        }",
      "    } catch (error) {",
      "        let errorObj = {",
      "            message: 'isLoggedIn middleware failed',",
      "            payload: error",
      "        }",
      "",
      "        console.log(errorObj);",
      "        res.json(errorObj);",
      "    }",
      "}",
      "",
      "module.exports = {",
      "    requireAuth,",
      "    isLoggedIn",
      "}"
    ],
    "description": "place in the router folder as authMiddleware.js, helps knowing if user is logged in on each page"
  }
}
